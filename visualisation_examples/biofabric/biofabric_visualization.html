<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Force-Directed Graph to Biofabric Visualization</title>
    <style>        
        #chart {
            width: 100%;
            height: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
           
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <button id="startBtn" onclick="startAnimation()">Start Animation</button>
            <button id="resetBtn" onclick="resetVisualization()" disabled>Reset</button>
        </div>
        <div id="chart"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script>
	let sampleData = {};
    let data, svg, simulation;

    fetch('sample_data.json')
        .then(response => response.json())
        .then(json => {
            sampleData = json;
            data = JSON.parse(JSON.stringify(sampleData)); // Deep copy
        })
        .catch(error => console.error('Error loading JSON:', error));

        const width = 1600;
        const height = 1000;
        const margin = { left: 100, right: 50, top: 50, bottom: 50 };

        // Color scale
        const color = d3.scaleOrdinal(d3.schemeCategory10);

        // Scales
        let y, x;

        // Animation state
        let isAnimating = false;

        // Helper functions
        function initGraph(data) {
            for (let i = 0; i < data.nodes.length; i++) {
                data.nodes[i].row = -1;
                data.nodes[i].degree = 0;
                data.nodes[i].neighbors = [];
                data.nodes[i].minCol = Number.MAX_SAFE_INTEGER;
                data.nodes[i].maxCol = Number.MIN_SAFE_INTEGER;
            }

            const nodeMap = data.nodes.reduce((map, obj, idx) => {
                map[obj.id] = idx;
                return map;
            }, {});

            for (let i = 0; i < data.links.length; i++) {
                const link = data.links[i];
                const source = data.nodes[nodeMap[link.source]];
                const target = data.nodes[nodeMap[link.target]];

                source.degree++;
                target.degree++;
                source.neighbors.push(target);
                target.neighbors.push(source);
            }
        }

        function compareNodeDegree(a, b) {
            return b.degree - a.degree;
        }

        function orderNodes(data) {
            data.nodes.sort(compareNodeDegree);
            for (let i = 0; i < data.nodes.length; i++) {
                data.nodes[i].neighbors.sort(compareNodeDegree);
            }
        }

        function assignRows(data) {
            let nextAvailableRow = 0;

            for (let i = 0; i < data.nodes.length; i++) {
                if (data.nodes[i].row !== -1) continue;

                const node = data.nodes[i];
                node.row = nextAvailableRow++;

                for (let j = 0; j < node.neighbors.length; j++) {
                    if (node.neighbors[j].row !== -1) continue;
                    node.neighbors[j].row = nextAvailableRow++;
                }
            }
        }

        function orderLinks(data) {
            const nodeMap = data.nodes.reduce((map, obj, idx) => {
                map[obj.id] = idx;
                return map;
            }, {});

            for (let i = 0; i < data.links.length; i++) {
                const source = data.nodes[nodeMap[data.links[i].source]];
                const target = data.nodes[nodeMap[data.links[i].target]];

                data.links[i].row = Math.min(source.row, target.row);
                data.links[i].height = Math.abs(target.row - source.row);
                data.links[i].index = i;
            }

            data.links.sort(function(a, b) {
                if (a.row !== b.row) {
                    return a.row - b.row;
                } else {
                    return a.height - b.height;
                }
            });

            // Reassign indices after sorting
            for (let i = 0; i < data.links.length; i++) {
                data.links[i].index = i;
            }
        }

        function computeRanges(data) {
            const nodeMap = data.nodes.reduce((map, obj, idx) => {
                map[obj.id] = idx;
                return map;
            }, {});

            for (let i = 0; i < data.links.length; i++) {
                const source = data.nodes[nodeMap[data.links[i].source]];
                const target = data.nodes[nodeMap[data.links[i].target]];

                source.minCol = Math.min(source.minCol, i);
                source.maxCol = Math.max(source.maxCol, i);

                target.minCol = Math.min(target.minCol, i);
                target.maxCol = Math.max(target.maxCol, i);
            }
        }

        function createChart() {
            // Reset data
            data = JSON.parse(JSON.stringify(sampleData));
            
            // Initialize graph data
            initGraph(data);
            orderNodes(data);
            assignRows(data);
            orderLinks(data);
            computeRanges(data);

            // Create scales
            y = d3.scaleBand()
                .domain(d3.range(data.nodes.length))
                .range([margin.top, height - margin.bottom])
                .padding(0.1);

            x = d3.scaleBand()
                .domain(d3.range(data.links.length))
                .range([margin.left, width - margin.right])
                .padding(0.1);

            // Create copies for D3 force simulation
            const links = data.links.map(d => Object.create(d));
            const nodes = data.nodes.map(d => Object.create(d));

            // Create force simulation
            simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id))
                .force("charge", d3.forceManyBody())
                .force("center", d3.forceCenter(width / 2, height / 2))
                .tick(300);

            // Clear previous chart
            d3.select("#chart").selectAll("*").remove();

            // Create SVG
            svg = d3.select("#chart")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height]);

            // Create links
            const link = svg.append("g")
                .attr("class", "link")
                .attr("stroke", "black")
                .selectAll("line")
                .data(links)
                .join("line")
                .attr("stroke-width", d => Math.sqrt(d.value));

            // Create nodes
            const node = svg.append("g")
                .attr("class", "node")
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .selectAll("circle")
                .data(nodes)
                .join("circle")
                .attr("opacity", 1)
                .attr("r", 5)
                .attr("fill", d => color(d.group));

            // Add node titles
            node.append("title")
                .text(d => d.id);

            // Position elements after simulation
            simulation.on("end", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
            });

            // Create node lines (initially hidden)
            const nodeLines = svg.append("g")
                .attr("class", "node_lines")
                .selectAll("line")
                .data(nodes)
                .join("line")
                .attr("stroke-width", 1.5)
                .attr("stroke", "#999")
                .attr("x1", d => d.x)
                .attr("y1", d => d.y)
                .attr("x2", d => d.x)
                .attr("y2", d => d.y);

            return { svg, link, node, nodeLines, nodes, links };
        }

        function startAnimation() {
            if (isAnimating) return;
            
            isAnimating = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('resetBtn').disabled = false;

            const { svg, link, node, nodeLines, nodes } = createChart();

            // Animation sequence
            const t1 = svg.transition().duration(1500);
            const t2 = svg.transition().delay(1500).duration(1500);
            const t3 = svg.transition().delay(3000).duration(1500);

            // Step 1: Extend node lines horizontally
            nodeLines
                .transition(t1)
                .attr("x1", margin.left)
                .attr("y1", d => d.y)
                .attr("x2", width - margin.right)
                .attr("y2", d => d.y);

            // Raise links and nodes above node lines
            svg.select(".link").raise();
            svg.select(".node").raise();

            // Step 2: Move nodes and links to their assigned rows
            node
                .transition(t2)
                .attr("cy", d => y(d.row));

            nodeLines
                .transition(t2)
                .attr("y1", d => y(d.row))
                .attr("y2", d => y(d.row));

            link
                .transition(t2)
                .attr("y1", d => y(d.source.row))
                .attr("y2", d => y(d.target.row));

            // Step 3: Collapse links to vertical lines
            link
                .transition(t3)
                .attr("stroke-width", 1.5)
                .attr("x1", d => x(d.index))
                .attr("x2", d => x(d.index));

            // Step 4: Fade out nodes
            node.transition()
                .delay(3000)
                .duration(1500)
                .attr("opacity", 0);

            // Step 5: Adjust node lines to show ranges
            nodeLines
                .transition()
                .delay(4500)
                .duration(1500)
                .attr("x1", d => x(d.minCol))
                .attr("x2", d => x(d.maxCol));

            // Step 6: Add labels
            const labels = svg.append("g")
                .attr("class", "labels")
                .attr("font-size", 8)
                .attr("text-anchor", "end")
                .attr("dominant-baseline", "middle")
                .attr("font-family", "sans-serif")
                .selectAll("text")
                .data(nodes)
                .join("text")
                .text(d => d.id)
                .attr("x", 0)
                .attr("y", d => y(d.row))
                .attr("stroke-width", 2)
                .attr("stroke", "white")
                .attr("stroke-linejoin", "round");

            // Add text without stroke for readability
            labels.clone(true)
                .attr("stroke", "none")
                .attr("fill", "black");

            // Animate labels
            svg.selectAll(".labels text")
                .transition()
                .delay(4500)
                .duration(1500)
                .attr("x", d => x(d.minCol) - 5);

            // Reset animation state after completion
            setTimeout(() => {
                isAnimating = false;
            }, 6000);
        }

        function resetVisualization() {
            if (isAnimating) return;
            
            d3.select("#chart").selectAll("*").remove();
            document.getElementById('startBtn').disabled = false;
            document.getElementById('resetBtn').disabled = true;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            resetVisualization();
        });
    </script>
</body>
</html>